#!/usr/bin/env python3
#
# This script depends on python-dateutil and python-pytz for properly handling
# times and time zones of calendar events.
import argparse
import datetime
import itertools
import logging
import os
import sys
import time
from typing import List, Optional, Set, Tuple, TypedDict

import dateutil.parser
import pytz

try:
    from google.oauth2.credentials import Credentials  # type: ignore[import-not-found]
    from googleapiclient.discovery import build
except ImportError:
    logging.exception("Install google-api-python-client and google-auth-oauthlib")
    sys.exit(1)
sys.path.append(os.path.join(os.path.dirname(__file__), "../../"))
import zulip

SCOPES = ["https://www.googleapis.com/auth/calendar.readonly"]
CLIENT_SECRET_FILE = "client_secret.json"  # noqa: S105
APPLICATION_NAME = "Zulip"
HOME_DIR = os.path.expanduser("~")


class Event(TypedDict):
    id: int
    start: datetime.datetime
    end: datetime.datetime
    summary: str
    html_link: str
    status: str
    location: str
    description: str
    organizer: str
    hangout_link: str
    reminder: int


# Our cached view of the calendar, updated periodically.
events: List[Event] = []

# Unique keys for reminders we've already sent, so we don't remind twice.
sent: Set[Tuple[int, datetime.datetime, int]] = set()

sys.path.append(os.path.dirname(__file__))

parser = zulip.add_default_arguments(
    argparse.ArgumentParser(
        r"""

google-calendar --calendar calendarID@example.calendar.google.com

    This integration can be used to send yourself reminders, on Zulip, of Google Calendar Events.

    Specify your Zulip API credentials and server in a ~/.zuliprc file or using the options.

    Before running this integration make sure you run the get-google-credentials file to give Zulip
    access to certain aspects of your Google Account.

    This integration should be run on your local machine. Your API key and other information are
    revealed to local users through the command line.

    Depends on: google-api-python-client
"""
    )
)


parser.add_argument(
    "--override",
    dest="override",
    type=int,
    action="store",
    help="Override the reminder time for all events.",
    metavar="MINUTES",
)

parser.add_argument(
    "--calendar",
    dest="calendarID",
    default="primary",
    type=str,
    action="store",
    help="Calendar ID for the calendar you want to receive reminders from.",
)

options = parser.parse_args()

if not options.zulip_email:
    parser.error("You must specify --user")

zulip_client = zulip.init_from_options(options)


def get_credentials() -> Credentials:
    """Gets valid user credentials from storage.

    If nothing has been stored, or if the stored credentials are invalid,
    an exception is thrown and the user is informed to run the script in this directory to get
    credentials.

    Returns:
        Credentials, the obtained credential.
    """
    try:
        credential_path = os.path.join(HOME_DIR, "google-credentials.json")
        credentials = Credentials.from_authorized_user_file(credential_path, SCOPES)
    except ValueError:
        logging.exception("Error while trying to open the `google-credentials.json` file.")
        sys.exit(1)
    except OSError:
        logging.error("Run the get-google-credentials script from this directory first.")
        sys.exit(1)
    else:
        return credentials


def populate_events() -> Optional[None]:
    creds = get_credentials()
    service = build("calendar", "v3", credentials=creds)
    feed = (
        service.events()
        .list(
            calendarId=options.calendarID,
            timeMin=datetime.datetime.now(pytz.utc).isoformat(),
            timeMax=datetime.datetime.now(pytz.utc).isoformat().split("T")[0] + "T23:59:59Z",
            singleEvents=True,
            orderBy="startTime",
        )
        .execute()
    )
    events.clear()
    for event in feed["items"]:
        try:
            start = dateutil.parser.parse(event["start"]["dateTime"])
            end = dateutil.parser.parse(event["end"]["dateTime"])
            # According to the API documentation, a time zone offset is required
            # for start.dateTime unless a time zone is explicitly specified in
            # start.timeZone.
            if start.tzinfo is None or end.tzinfo is None:
                event_timezone = pytz.timezone(event["start"]["timeZone"])
                # pytz timezones include an extra localize method that's not part
                # of the tzinfo base class.
                start = event_timezone.localize(start)
                end = event_timezone.localize(end)
        except KeyError:
            # All-day events can have only a date.
            start_naive = dateutil.parser.parse(event["start"]["date"])
            end_naive = dateutil.parser.parse(event["end"]["date"])
            # All-day events don't have a time zone offset; instead, we use the
            # time zone of the calendar.
            calendar_timezone = pytz.timezone(feed["timeZone"])
            # pytz timezones include an extra localize method that's not part
            # of the tzinfo base class.
            start = calendar_timezone.localize(start_naive)
            end = calendar_timezone.localize(end_naive)
        now = datetime.datetime.now(tz=start.tzinfo)
        if start < now:
            continue
        id = event["id"]
        summary = event.get("summary", "(No Title)")
        html_link = event["htmlLink"]
        status = event.get("status", "confirmed")
        location = event.get("location", "")
        description = event.get("description", "")
        organizer = (
            ""
            if (
                event["organizer"]["email"] == options.zulip_email or event["organizer"].get("self")
            )
            else event["organizer"].get("displayName", event["organizer"]["email"])
        )
        hangout_link = event.get("hangoutLink", "")
        reminders = event["reminders"]
        # If the user has specified an override, we use that for all events.
        # If the event uses the calendar's default reminders, we use that.
        # If the event has overrides on Google Calendar, we use that.
        # If none of the above, we don't set a reminder.
        if options.override:
            reminder_minutes = [options.override]
        elif reminders.get("useDefault"):
            calendar_list = service.calendarList().get(calendarId=options.calendarID).execute()
            reminder_minutes = (
                [reminder["minutes"] for reminder in calendar_list["defaultReminders"]]
                if calendar_list.get("defaultReminders")
                else []
            )
        elif reminders.get("overrides"):
            reminder_minutes = [reminder["minutes"] for reminder in reminders["overrides"]]
        else:
            reminder_minutes = []
        events.extend(
            {
                "id": id,
                "start": start,
                "end": end,
                "summary": summary,
                "html_link": html_link,
                "status": status,
                "location": location,
                "description": description,
                "organizer": organizer,
                "hangout_link": hangout_link,
                "reminder": reminder,
            }
            for reminder in reminder_minutes
        )


def event_to_message(event: Event) -> str:
    """Parse the event dictionary and return a string that can be sent as a message.

    The message includes the event title, start and end times, location, organizer, hangout link, and description.

    Returns:
        str: The message to be sent.
    """
    line = f"**[{event['summary']}]({event['html_link']})**\n"
    if event["start"].hour == 0 and event["start"].minute == 0:
        line += "Scheduled for today.\n"
    else:
        line += f"Scheduled from **{event['start'].strftime('%H:%M')}** to **{event['end'].strftime('%H:%M')}**.\n"
    line += f"**Location:** {event['location']}\n" if event["location"] else ""
    line += f"**Organizer:** {event['organizer']}\n" if event["organizer"] else ""
    line += (
        f"**Hangout Link:** [{event['hangout_link'].split('/')[2]}]({event['hangout_link']})\n"
        if event["hangout_link"]
        else ""
    )
    line += f"**Status:** {event['status']}\n" if event["status"] else ""
    line += f"**Description:** {event['description']}\n" if event["description"] else ""
    return line


def send_reminders() -> Optional[None]:
    messages: List[str] = []
    keys = set()
    # Sort events by the time of the reminder.
    events.sort(
        key=lambda event: (event["start"] - datetime.timedelta(minutes=event["reminder"])),
        reverse=True,
    )
    # Iterate through the events and send reminders for those whose reminder time has come or passed and remove them from the list.
    # The instant a reminder's time is greater than the current time, we stop sending reminders and break out of the loop.
    while len(events):
        event = events[-1]
        now = datetime.datetime.now(tz=event["start"].tzinfo)
        dt = event["start"] - datetime.timedelta(minutes=event["reminder"])
        if dt <= now:
            key = (event["id"], event["start"], event["reminder"])
            if key not in sent:
                line = event_to_message(event)
                print("Sending reminder:", line)
                messages = [line, *messages]
                keys.add(key)
                events.pop()
        else:
            break

    if not messages:
        return

    if len(messages) == 1:
        message = "**Reminder:**\n\n " + messages[0]
    else:
        message = "**Reminders:**\n\n" + "\n".join(
            str(i + 1) + ". " + m for i, m in enumerate(messages)
        )

    zulip_client.send_message(dict(type="private", to=options.zulip_email, content=message))

    sent.update(keys)


# Loop forever
for i in itertools.count():
    try:
        # We check reminders every minute, but only
        # download the calendar every 10 minutes.
        if not i % 10:
            populate_events()
        send_reminders()
    except Exception:
        logging.exception("Couldn't download Google calendar and/or couldn't post to Zulip.")
    time.sleep(60)
